package squirecmds

import (
	"bufio"
	"errors"
	"os"
	"path/filepath"
	"strings"

	"github.com/mikeschinkel/go-cfgstore"
	"github.com/mikeschinkel/go-cliutil"
	"github.com/mikeschinkel/go-dt"
	"github.com/mikeschinkel/squire/squirepkg/squire"
)

var _ cliutil.CommandHandler = (*InitCmd)(nil)

// InitCmd creates .squire/config.json files for repos
type InitCmd struct {
	*cliutil.CmdBase
	filePath string
	dirArg   string
}

// ModuleConfig represents a single module in the repo config
type ModuleConfig struct {
	Name string   `json:"name"`
	Role []string `json:"role"`
}

// RepoConfig represents the .squire/config.json structure
type RepoConfig struct {
	Modules map[string]ModuleConfig `json:"modules"`
}

func init() {
	var cmd *InitCmd
	var err error

	cmd = &InitCmd{
		filePath: "",
		dirArg:   "",
	}

	cmd.CmdBase = cliutil.NewCmdBase(cliutil.CmdArgs{
		Order:       5,
		Name:        "init",
		Usage:       "init [<dir>] | init --file <path>",
		Description: "Initialize .squire/config.json for repos (scans directory or reads from file)",
		ArgDefs: []*cliutil.ArgDef{
			{
				Name:     "dir",
				Usage:    "Directory to scan and initialize (defaults to current directory)",
				Required: false,
				String:   &cmd.dirArg,
				Example:  "~/Projects",
			},
		},
		FlagSets: []*cliutil.FlagSet{
			{
				Name: "init",
				FlagDefs: []cliutil.FlagDef{
					{
						Name:     "file",
						Shortcut: 'f',
						Usage:    "Path to file — generated by 'scan' command — containing go.mod paths (one per line)",
						String:   &cmd.filePath,
						Required: false,
					},
				},
			},
		},
	})

	err = cliutil.RegisterCommand(cmd)
	if err != nil {
		panic(err)
	}
}

// Handle executes the init command
func (c *InitCmd) Handle() (err error) {
	var config *squire.Config
	var goModPaths []dt.Filepath
	var repoModules map[dt.DirPath][]dt.DirPath
	var errs []error
	var repoRoot dt.DirPath
	var modules []dt.DirPath
	var initialized int
	var skipped int

	config = c.Config.(*squire.Config)

	// Check for mutual exclusivity
	if c.filePath != "" && c.dirArg != "" {
		err = NewErr(ErrCommand, ErrInit, ErrParsing, "error", "cannot specify both --file and <dir>")
		goto end
	}

	// Determine mode: file-based or directory-based
	if c.filePath != "" {
		// File mode: read go.mod paths from file
		goModPaths, err = c.readGoModFile(config)
		if err != nil {
			goto end
		}

		if len(goModPaths) == 0 {
			config.Writer.Printf("No valid go.mod paths found in file\n")
			goto end
		}
	} else {
		// Directory mode: scan directory for go.mod files
		goModPaths, err = c.scanDirectory(config)
		if err != nil {
			goto end
		}

		if len(goModPaths) == 0 {
			config.Writer.Printf("No go.mod files found in directory\n")
			goto end
		}
	}

	// Group go.mod paths by repo root
	repoModules, errs = c.groupByRepo(goModPaths, config)
	if len(errs) > 0 {
		err = c.reportErrors(errs, config)
		goto end
	}

	// Process each repo
	for repoRoot, modules = range repoModules {
		err = c.initializeRepo(repoRoot, modules, config)
		if err != nil {
			if isAlreadyManaged(err) {
				config.Writer.Printf("Skipped %s (already managed)\n", repoRoot)
				skipped++
				err = nil
				continue
			}
			config.Writer.Errorf("Failed to initialize %s: %v\n", repoRoot, err)
			continue
		}
		config.Writer.Printf("Initialized %s\n", repoRoot)
		initialized++
	}

	// Print summary
	config.Writer.Printf("\nSummary:\n")
	config.Writer.Printf("  Initialized: %d repos\n", initialized)
	config.Writer.Printf("  Skipped:     %d repos\n", skipped)

end:
	return err
}

// scanDirectory scans a directory for go.mod files
func (c *InitCmd) scanDirectory(config *squire.Config) (goModPaths []dt.Filepath, err error) {
	var dirPath dt.DirPath
	var arg string
	var de dt.DirEntry
	var walkErr error
	var goModPath dt.Filepath

	// Get directory argument or default to current directory
	if c.dirArg == "" {
		arg = "."
	} else {
		arg = c.dirArg
	}

	// Parse and expand the directory path
	dirPath, err = parseAndExpandDirPath(arg)
	if err != nil {
		err = NewErr(ErrCommand, ErrInit, ErrFileOperation, "path", arg, err)
		goto end
	}

	// Walk the directory tree looking for go.mod files
	for de, walkErr = range dirPath.Walk() {
		if walkErr != nil {
			config.Logger.Warn("error accessing path", "path", de.Rel, "error", walkErr)
			continue
		}

		// Skip if not a go.mod file
		if de.IsDir() || de.Entry.Name() != "go.mod" {
			continue
		}

		// Build absolute filepath from root and relative path
		goModPath = dt.FilepathJoin(dirPath, de.Rel)

		// Add all go.mod files (we'll filter by repo later)
		goModPaths = append(goModPaths, goModPath)
	}

end:
	return goModPaths, err
}

// readGoModFile reads the input file and returns a list of go.mod paths
func (c *InitCmd) readGoModFile(config *squire.Config) (paths []dt.Filepath, err error) {
	var inputPath dt.Filepath
	var file *os.File
	var scanner *bufio.Scanner
	var lineNum int
	var line string
	var goModPath dt.Filepath
	var exists bool

	// Parse and expand the input file path
	inputPath, err = parseAndExpandFilepath(c.filePath)
	if err != nil {
		err = NewErr(ErrCommand, ErrInit, ErrFileOperation, "path", c.filePath, err)
		goto end
	}

	file, err = inputPath.Open()
	if err != nil {
		err = NewErr(ErrCommand, ErrInit, ErrFileOperation, "filepath", inputPath, err)
		goto end
	}
	defer dt.CloseOrLog(file)

	scanner = bufio.NewScanner(file)
	lineNum = 0

	for scanner.Scan() {
		lineNum++
		line = strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse and expand go.mod path
		goModPath, err = parseAndExpandFilepath(line)
		if err != nil {
			config.Logger.Warn("failed to parse path", "line", lineNum, "path", line, "error", err)
			err = nil
			continue
		}

		// Verify file exists
		exists, err = goModPath.Exists()
		if err != nil || !exists {
			config.Logger.Warn("go.mod file does not exist", "line", lineNum, "path", goModPath)
			err = nil
			continue
		}

		paths = append(paths, goModPath)
	}

	err = scanner.Err()
	if err != nil {
		err = NewErr(ErrCommand, ErrInit, ErrFileOperation, "filepath", inputPath, err)
		goto end
	}

end:
	return paths, err
}

// groupByRepo groups go.mod paths by their repo root
func (c *InitCmd) groupByRepo(goModPaths []dt.Filepath, config *squire.Config) (repoModules map[dt.DirPath][]dt.DirPath, errs []error) {
	var goModPath dt.Filepath
	var moduleDir dt.DirPath
	var repoRoot dt.DirPath
	var err error

	repoModules = make(map[dt.DirPath][]dt.DirPath)

	for _, goModPath = range goModPaths {
		// Get the directory containing go.mod
		moduleDir = goModPath.Dir()

		// Find the repo root
		repoRoot, err = findRepoRoot(moduleDir)
		if err != nil {
			err = NewErr(ErrCommand, ErrInit, ErrGrouping, "go_mod_path", goModPath, err)
			errs = append(errs, err)
			continue
		}

		// Add to the repo's module list
		repoModules[repoRoot] = append(repoModules[repoRoot], moduleDir)
	}

	return repoModules, errs
}

// initializeRepo creates .squire/config.json for a repo using cfgstore
func (c *InitCmd) initializeRepo(repoRoot dt.DirPath, moduleDirs []dt.DirPath, config *squire.Config) (err error) {
	var store cfgstore.ConfigStore
	var configPath dt.Filepath
	var exists bool
	var modules map[string]ModuleConfig
	var moduleDir dt.DirPath
	var relPath string
	var moduleName string
	var role string
	var repoConfig *RepoConfig

	// Create a config store for this specific repo root
	store = cfgstore.NewConfigStore(cfgstore.ProjectConfigDirType, cfgstore.ConfigStoreArgs{
		ConfigSlug:  squire.ConfigSlug,
		RelFilepath: squire.ConfigFile,
		DirsProvider: &cfgstore.DirsProvider{
			ProjectDirFunc: func() (dt.DirPath, error) {
				return repoRoot, nil
			},
		},
	})

	// Check if config already exists
	configPath, err = store.GetFilepath()
	if err != nil {
		err = NewErr(ErrCommand, ErrInit, ErrFileOperation, "repo_root", repoRoot, err)
		goto end
	}

	exists = store.Exists()
	if exists {
		err = NewErr(ErrCommand, ErrInit, ErrAlreadyManaged, "repo_root", repoRoot)
		goto end
	}

	// Build the modules map
	modules = make(map[string]ModuleConfig)
	for _, moduleDir = range moduleDirs {
		// Calculate relative path from repo root
		relPath, err = filepath.Rel(string(repoRoot), string(moduleDir))
		if err != nil {
			err = NewErr(ErrCommand, ErrInit, ErrFileOperation, "repo_root", repoRoot, "module_dir", moduleDir, err)
			goto end
		}

		// Convert to ./ notation
		if relPath == "." {
			relPath = "./"
		} else {
			relPath = "./" + relPath
		}

		// Derive module name (last path segment, or repo name for root)
		if relPath == "./" {
			moduleName = string(repoRoot.Base())
		} else {
			moduleName = string(moduleDir.Base())
		}

		// Infer role from path
		role = inferRole(relPath)

		modules[relPath] = ModuleConfig{
			Name: moduleName,
			Role: []string{role},
		}
	}

	// Create the repo config
	repoConfig = &RepoConfig{
		Modules: modules,
	}

	// Save config using cfgstore (handles directory creation and JSON marshaling)
	err = store.SaveJSON(repoConfig)
	if err != nil {
		err = NewErr(ErrCommand, ErrInit, ErrFileOperation, "config_path", configPath, err)
		goto end
	}

end:
	return err
}

// inferRole infers the module role from its path
func inferRole(relPath string) (role string) {
	var normalized string

	// Normalize path for comparison
	normalized = strings.ToLower(filepath.ToSlash(relPath))

	if strings.Contains(normalized, "/cmd/") || strings.HasPrefix(normalized, "./cmd") {
		role = "cli"
		goto end
	}

	if strings.Contains(normalized, "/test/") || strings.HasPrefix(normalized, "./test") {
		role = "test"
		goto end
	}

	role = "lib"

end:
	return role
}

// parseAndExpandFilepath expands ~ and converts to absolute Filepath
func parseAndExpandFilepath(pathStr string) (fp dt.Filepath, err error) {
	var expanded dt.Filepath
	var absPath dt.Filepath

	// Convert string to Filepath and expand tilde
	expanded, err = expandTildeFilepath(dt.Filepath(pathStr))
	if err != nil {
		err = NewErr(ErrFileOperation, "path", pathStr, err)
		goto end
	}

	// Make absolute
	absPath, err = absFilepath(expanded)
	if err != nil {
		err = NewErr(ErrFileOperation, "path", expanded, err)
		goto end
	}

	fp = absPath

end:
	return fp, err
}

// expandTildeFilepath expands ~ to the user's home directory for Filepath
func expandTildeFilepath(path dt.Filepath) (expanded dt.Filepath, err error) {
	var pathStr string
	var home string
	var homeDir dt.DirPath

	pathStr = string(path)

	if !strings.HasPrefix(pathStr, "~") {
		expanded = path
		goto end
	}

	home, err = os.UserHomeDir()
	if err != nil {
		goto end
	}
	homeDir = dt.DirPath(home)

	if pathStr == "~" {
		expanded = dt.Filepath(homeDir)
		goto end
	}

	if strings.HasPrefix(pathStr, "~/") {
		expanded = dt.FilepathJoin(homeDir, pathStr[2:])
		goto end
	}

	expanded = path

end:
	return expanded, err
}

// absFilepath returns absolute Filepath
func absFilepath(path dt.Filepath) (absPath dt.Filepath, err error) {
	var abs string

	abs, err = filepath.Abs(string(path))
	if err != nil {
		goto end
	}

	absPath = dt.Filepath(abs)

end:
	return absPath, err
}

// isAlreadyManaged checks if an error indicates repo is already managed
func isAlreadyManaged(err error) (managed bool) {
	managed = errors.Is(err, ErrAlreadyManaged)
	return managed
}

// reportErrors reports multiple errors and returns a combined error
func (c *InitCmd) reportErrors(errs []error, config *squire.Config) (err error) {
	var e error

	for _, e = range errs {
		config.Writer.Errorf("%v\n", e)
	}

	err = NewErr(ErrCommand, ErrInit, ErrGrouping, "error_count", len(errs))

	return err
}
